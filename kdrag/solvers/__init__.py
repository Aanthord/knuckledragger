import kdrag as kd
import kdrag.smt as smt
import subprocess
import os
import concurrent.futures
import logging
import shutil
import re

logger = logging.getLogger("knuckledragger")


def binpath(cmd):
    return os.path.join(os.path.dirname(__file__), cmd)


def install_solvers():
    print("Installing solvers")
    subprocess.run(["bash", binpath("install.sh")], check=True)


def run(cmd, args, **kwargs):
    cmd = [binpath(cmd)] + args
    return subprocess.run(cmd, **kwargs)


def smtlib_datatypes(dts: list[smt.DatatypeSortRef]) -> str:
    s = smt.Z3Solver()
    for dt in dts:
        x = smt.Const("x", dt)
        s.add(smt.Exists([x], x == x))  # trivial constraint
    return (
        s.to_smt2()
        .replace("(check-sat)", "")
        .replace(
            """; benchmark generated from python API\n(set-info :status unknown)\n""",
            "",
        )
    )


class BaseSolver:
    x, y, z = smt.Reals("x y z")
    n, m, k = smt.Ints("n m k")
    a, b, c = smt.Bools("a b c")
    predefined = [
        # smt.Function("abs", smt.RealSort(), smt.RealSort()),
        smt.And(a, b).decl(),
        smt.Or(a, b).decl(),
        smt.Not(a).decl(),
        smt.Implies(a, b).decl(),
        (n - m).decl(),
        (n + m).decl(),
        (n * m).decl(),
        (n == m).decl(),
        (n <= m).decl(),
    ]
    predefined_sorts = [
        "Int",
        "Real",
        "Bool",
    ]
    # Some are polymorphic so decl doesn't work
    predefined_names = [
        "=",
        "if",
        "and",
        "or",
        "not",
        "=>",
        "select",
        "store",
        "=>",
        ">",
        "<",
        ">=",
        "<=",
        "+",
        "-",
        "*",
        "/",
        "^",
        "is",
        "Int",
        "Real",
        "abs",
        "distinct",
        "true",
        "false",
    ]

    def __init__(self):
        self.adds = []
        self.assert_tracks = []
        self.options = {}

    def add(self, thm: smt.BoolRef):
        assert isinstance(thm, smt.BoolRef)
        self.adds.append(thm)

    def assert_and_track(self, thm: smt.BoolRef, name: str):
        assert isinstance(thm, smt.BoolRef)
        self.assert_tracks.append((thm, name))

    def check(self):
        raise NotImplementedError

    def unsat_core(self):
        raise NotImplementedError

    def proof(self):
        return self.res.stdout

    def set(self, option, value):
        self.options[option] = value

    def write_tptp(self, filename, format="thf"):
        assert format in ["thf", "tff", "fof"]
        logging.info("Writing TPTP file to %s", filename)
        with open(filename, "w") as fp:
            fp.write("% TPTP file generated by Knuckledragger\n")

            # Gather up all datatypes and function symbols
            sorts = set()
            predefined = set()

            if format != "fof":
                # Write sorts in TPTP THF format
                for sort in collect_sorts(
                    self.adds + [thm for thm, name in self.assert_tracks]
                ):
                    # Write sort declarations (only for user-defined sorts)
                    name = sort.name()
                    if name not in self.predefined_sorts:
                        if format != "fof":
                            fp.write(
                                f"{format}({name.lower()}_type, type, {kd.utils.sort_to_tptp(sort)} : $tType ).\n"
                            )
                    if isinstance(sort, smt.DatatypeSortRef):
                        # TODO: add constructors and injectivity axioms
                        for i in range(sort.num_constructors()):
                            predefined.add(sort.constructor(i))
                            predefined.add(sort.recognizer(i))
                            for j in range(sort.constructor(i).arity()):
                                predefined.add(sort.accessor(i, j))

                # Declare all function symbols in TPTP THF format
                fp.write("% Declarations\n")
                for f in collect_decls(
                    self.adds + [thm for thm, name in self.assert_tracks]
                ):
                    if f not in predefined and f.name() not in self.predefined_names:
                        if f.arity() == 0:
                            fp.write(
                                f"{format}({f.name()}_type, type, {kd.utils.mangle_decl(f)} : {kd.utils.sort_to_tptp(f.range())} ).\n"
                            )
                        else:
                            joiner = " > " if format == "thf" else " * "
                            dom_tptp = joiner.join(
                                [
                                    kd.utils.sort_to_tptp(f.domain(i))
                                    for i in range(f.arity())
                                ]
                            )
                            fp.write(
                                f"{format}({f.name()}_decl, type, {kd.utils.mangle_decl(f)} : {dom_tptp} > {kd.utils.sort_to_tptp(f.range())}).\n"
                            )

            # Write axioms and assertions in TPTP THF format
            fp.write("% Axioms and assertions\n")
            for i, e in enumerate(self.adds):
                fp.write(
                    f"{format}(ax_{i}, axiom, {kd.utils.expr_to_tptp(e, format=format)}).\n"
                )
            for thm, name in self.assert_tracks:
                fp.write(
                    f"{format}({name}, axiom, {kd.utils.expr_to_tptp(thm, format=format)}).\n"
                )
            # fp.write("tff(goal, conjecture, $false).\n")

            fp.flush()

    def check_tptp_status(self, res):
        if b"SZS status Unsatisfiable" in res:
            self.status = smt.unsat
            return smt.unsat
        elif b"SZS status Satisfiable" in res:
            self.status = smt.sat
            return smt.sat
        elif b"SZS status GaveUp" in res:
            self.status = smt.unknown
            return smt.unknown
        else:
            raise Exception("Unexpected return from solver", res)

    def write_smt(self, fp):
        fp.write("(set-logic ALL)\n")
        # Gather up all datatypes referenced
        sorts = set()
        predefined = set()
        for sort in collect_sorts(
            self.adds + [thm for thm, name in self.assert_tracks]
        ):
            if isinstance(sort, smt.DatatypeSortRef):
                fp.write(smtlib_datatypes([sort]))
                for i in range(sort.num_constructors()):
                    predefined.add(sort.constructor(i))
                    predefined.add(sort.recognizer(i))
                    for j in range(sort.constructor(i).arity()):
                        predefined.add(sort.accessor(i, j))
            elif isinstance(sort, smt.ArraySortRef):
                continue
            elif sort.name() not in self.predefined_sorts:
                fp.write(f"(declare-sort {sort.name()} 0)\n")
        # Declare all function symbols
        fp.write(";;declarations\n")
        for f in collect_decls(self.adds + [thm for thm, name in self.assert_tracks]):
            if f not in predefined and f.name() not in self.predefined_names:
                fp.write(f.sexpr())
                fp.write("\n")
        fp.write(";;axioms\n")
        for e in self.adds:
            fp.write("(assert " + e.sexpr() + ")\n")
        for thm, name in self.assert_tracks:
            fp.write("(assert (! " + thm.sexpr() + " :named " + name + "))\n")


def collect_sorts(exprs):
    sorts = set()
    for thm in exprs:
        todo = list(kd.utils.sorts(thm))
        while len(todo) > 0:
            sort = todo.pop()
            if sort not in sorts:
                if isinstance(sort, smt.ArraySortRef):
                    todo.append(sort.domain())
                    todo.append(sort.range())
                else:
                    sorts.add(sort)
    return sorts


def collect_decls(exprs):
    decls = set()
    for thm in exprs:
        decls.update(kd.utils.decls(thm))
    return decls


class VampireSolver(BaseSolver):
    def __init__(self):
        super().__init__()

    def check(self):
        with open("/tmp/vampire.smt2", "w") as fp:  # tempfile.NamedTemporaryFile()
            self.write_smt(fp)
            fp.write("(check-sat)\n")
            fp.flush()
            # print(fp.readlines())
            cmd = [
                binpath("vampire"),
                fp.name,
                "--mode",
                "smtcomp",
                "--input_syntax",
                "smtlib2",
                # "--ignore_unrecognized_logic", "on",
                # "--proof_extra" "fast" / "full"
                # "--latex_output" "/tmp/vampire.tex"
            ]
            if "timeout" in self.options:
                cmd.extend(["-t", str(self.options["timeout"] // 100) + "d"])
            if len(self.assert_tracks) > 0:
                cmd.extend(["--output_mode", "ucore"])
            else:
                cmd.extend(["--output_mode", "smtcomp"])

            self.res = subprocess.run(
                cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE
            )
        res = self.res.stdout
        if b"unsat\n" in res or b"% SZS status Unsatisfiable" in res:
            self.status = smt.unsat
            return smt.unsat
        elif b"sat\n" in res or b"% SZS status Satisfiable" in res:
            return smt.sat
        else:
            return smt.unknown

    def query(self, q):
        with open("/tmp/vampire.smt2", "w") as fp:  # tempfile.NamedTemporaryFile()
            # TODO: Since some sorts may be needed to be collected from the query, we're missing them
            # However, if you introduce new stuff in the query, that's kind of weird. Still useful possibly without fixing this.
            # self.add(smt.Not(q))
            self.write_smt(fp)
            # self.adds.pop()
            fp.write(f"(assert-not {q.sexpr()})")
            fp.write("(check-sat)\n")
            fp.flush()
            # print(fp.readlines())
            cmd = [
                binpath("vampire"),
                fp.name,
                "--mode",
                "casc",
                "--question_answering",
                "synthesis",  # "answer_literal"
                "--proof",
                "off",
                "--input_syntax",
                "smtlib2",  # "--ignore_unrecognized_logic", "on",
            ]
            if "timeout" in self.options:
                cmd.extend(["-t", str(self.options["timeout"] // 100) + "d"])

            self.res = subprocess.run(
                cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE
            )
        res = self.res.stdout
        return [
            line for line in res.decode().splitlines() if "% SZS answers Tuple" in line
        ]

    def unsat_core(self):
        assert self.status == smt.unsat
        cores = (
            self.res.stdout.decode()
            .split("unsat\n")[1]
            .replace("(", "")
            .replace(")", "")
            .split()
        )
        cores = [smt.Bool(core) for core in cores]
        return cores

    def proof(self):
        res = []
        # https://github.com/teorth/equational_theories/blob/main/equational_theories/Generated/VampireProven/src/vampire_proofs_cyc.py
        for eqnum, statement, reason in re.findall(
            r"(\d+)\. ([^[]+) \[([^\]]+)\]", self.res.stdout.decode()
        ):
            res.append((int(eqnum), statement, reason))  # TODO: Deeper parsing
        return res


class VampireTHFSolver(BaseSolver):
    def __init__(self):
        super().__init__()

    def check(self):
        self.write_tptp("/tmp/vampire.p")
        cmd = [
            binpath("vampire-ho"),
            "/tmp/vampire.p",
            "--mode",
            "portfolio",
            "--schedule",
            "snake_slh",
            "--input_syntax",
            "tptp",
        ]
        if "timeout" in self.options:
            cmd.extend(["-t", str(self.options["timeout"] // 100) + "d"])

        self.res = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        return self.check_tptp_status(self.res.stdout)


class EProverTHFSolver(BaseSolver):
    def check(self):
        filename = "/tmp/eprover.p"
        self.write_tptp(filename)
        cmd = [
            binpath("eprover-ho"),
            "--auto-schedule=8",
            filename,
        ]
        if "timeout" in self.options:
            cmd.extend(["--cpu-limit=" + str(self.options["timeout"] // 1000 + 1)])
        self.res = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if len(self.res.stderr) > 0:
            raise Exception("Eprover error", self.res.stderr)
        return self.check_tptp_status(self.res.stdout)


class ZipperpositionSolver(BaseSolver):
    def __init__(self):
        super().__init__()

    def check(self):
        filename = "/tmp/zipperposition.p"
        self.write_tptp(filename)
        cmd = [
            "zipperposition",
            "--mode",
            "best",
            filename,
        ]
        if "timeout" in self.options:
            cmd.extend(["--timeout", str(self.options["timeout"] // 1000 + 1)])

        self.res = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        return self.check_tptp_status(self.res.stdout)


class LeoIIISolver(BaseSolver):
    def check(self):
        filename = "/tmp/leo3.p"
        self.write_tptp(filename)
        cmd = [
            "java",
            "-jar",
            binpath("leo3.jar"),
            filename,
        ]
        if "timeout" in self.options:
            cmd.extend(["-t", str(self.options["timeout"] // 1000 + 1)])

        self.res = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        return self.check_tptp_status(self.res.stdout)


class TweeSolver(BaseSolver):
    def check(self):
        filename = "/tmp/twee.p"

        self.write_tptp(filename, format="tff")
        # cmd = [binpath("vampire"), "--mode", "clausify", filename]
        # with open("/tmp/twee2.p", "w") as fp:
        #    res = subprocess.run(cmd, stdout=fp, stderr=subprocess.PIPE)
        cmd = [
            binpath("twee"),
            "--tstp",
            "/tmp/twee.p",
        ]
        # if "timeout" in self.options:
        #    cmd.extend(["-t", str(self.options["timeout"] // 1000 + 1)])

        self.res = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        return self.check_tptp_status(self.res.stdout)


class SATSolver:
    def __init__(self):
        self.G = smt.Goal()
        self.cmd = [binpath("kissat/build/kissat"), "--relaxed"]

    def add(self, clause):
        self.G.add(clause)

    def check(self, debug=False):
        t = smt.Then("simplify", "bit-blast", "tseitin-cnf")
        c = t(self.G)
        assert len(c) == 1
        with open("/tmp/sat.cnf", "w") as f:
            f.write(c[0].dimacs())
            f.flush()
        self.res = subprocess.run(self.cmd + ["/tmp/sat.cnf"], capture_output=True)
        res = self.res.stdout.decode()
        if "s SATISFIABLE" in res:
            return smt.sat
        elif "s UNSATISFIABLE" in res:
            return smt.unsat
        else:
            return smt.unknown


class NanoCopISolver(BaseSolver):
    def check(self):
        filename = "/tmp/nanocopi.p"
        self.write_tptp(filename, format="fof")
        cmd = [
            binpath("nanoCoP-i20/nanocopi.sh"),
            filename,
        ]
        if "timeout" in self.options:
            cmd.extend(str(self.options["timeout"] // 1000 + 1))

        self.res = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        if b"intuitionistically Satisfiable" in self.res.stdout:
            return smt.sat
        elif b"intuitionistically Unsatisfiable" in self.res.stdout:
            return smt.unsat
        else:
            return smt.unknown


class MultiSolver(BaseSolver):
    solver_classes = [
        VampireTHFSolver,
        EProverTHFSolver,
        LeoIIISolver,
    ]
    if shutil.which("zipperposition") is not None:
        solver_classes.append(ZipperpositionSolver)

    def __init__(self, solvers=None, strict=False):
        super().__init__()
        if solvers is not None:
            self.solvers = solvers
        else:
            self.solvers = [s() for s in self.solver_classes]

    def add(self, thm):
        for s in self.solvers:
            s.add(thm)

    def assert_and_track(self, thm, name):
        for s in self.solvers:
            s.assert_and_track(thm, name)

    def set(self, option, value):
        for s in self.solvers:
            s.set(option, value)

    def check(self, strict=False):
        # TODO: This is working very sporadically
        """
        with concurrent.futures.ThreadPoolExecutor(
            max_workers=len(self.solvers)
        ) as executor:
                results = list(executor.map(lambda s: s.check(), self.solvers))
        """
        results = list(map(lambda s: s.check(), self.solvers))
        if smt.sat in results and smt.unsat in results:
            raise Exception(
                "Inconsistent results from solvers",
                {s.__class__.__name__: res for s, res in zip(self.solvers, results)},
            )
        if strict:
            if not all(r == results[0] for r in results):
                raise Exception(
                    "Inconsistent results from solvers",
                    {
                        s.__class__.__name__: res
                        for s, res in zip(self.solvers, results)
                    },
                )
        if smt.unsat in results:
            return smt.unsat
        elif smt.sat in results:
            return smt.sat
        else:
            return smt.unknown
